
// 주석으로 처리되는 글자들은슬래쉬 두개를 쓴다
// 코드로 인식되지 않음


int main()
{
	// int : 자료형(date type) 어떤 자료의 형태인지 알려줌
	// i : 변수명 (자유롭게 정할수 있다)
	// 자료형 (괄호안은 크기 byte)
	// 정수형 : char(1), short(2), int(4), long(4), long long(8)
	// 실수형: float(4), double(8)
	// 1byte를 더 쪼개면 8bit로 나뉜다 이때 1비트가 메모리에서 최소단위 (0 or 1) 
	// 4byte = 32비트
	// 2의 10승 = 1kbyte, 1024kb = 1 MB, 1024MB = 1GB, 1024GB = 1TB ...
	// 1byte로 할수 있는 건? 1byte = 8bit
	// 8bit로 표현할 수 있는 가지수는 2**8 = 256가지 인데 
	// 이것으로 표현할 수있는 수의범위(정수만, 양수만) = 0 ~ 255까지
	// 정수형, 실수형을 나누는 이유는 메모리를 다루고 표현하는 방식이 완전히 다르기 때문이다.
	// 실수는 0 ~ 1까지 보더라도 무한대이다. 이것을 어떻게 비트로 표현할까? 부동소수점이라는 표현방식을 사용한다.
	

	// 실수를 상수로 적을 경우 소수점 뒤에 f를 붙이면 float 자료형으로, f를 붙이지 않으면 double 자료형으로 간주한다.
	// 0.1f; 0.1

	// 연산자
	// 대입연산자, =
	// ; = 세미콜론, 현재 구문의 명령어가 다 끝낫다는 의미
	// 산술 연산자
	// +, -, *, /, %(모듈러스, 나머지, 피연산자가 모두 정수)
	// ++, --

	int data = 10 + 10;
	// data에는 20이 들어간다. 연산자 우선순위가 있다. = 와 + 둘다 연산자인데 + 가 먼저 수행됨, = 가 먼저 수행되면 data는 10
	// data + 20;
	// data가 40이 되나? cpu는 임시로 레지스터 메로리를 통해서 중간 연산을 저장한다. 그러니 결과를 집어넣지 않으면 날라간다.
	// data = data + 20;
	// 이러면 40 됨
	// data = data + 20; = data += 20; 같은 뜻이다
	data += 20;
	// data에다 20을 더한것을 다시 집어넣는 것

	// 연산을 당하는 것은 피연산자
	// 피연산자가 실수면 소수점으로 계속 떨어짐
	// 정수끼리의 나눗셈은 나머지가 생길 수 있다
	data = 10 / 3;
	// 이러면 3이 나옴
	data = 10 % 3;
	// 1이 나온다. 
	// 실수끼리의 나눗셈에서 나머지는 계속 소수점으로 떨어진다
	data = 10. % 3.;
	// 이러면 오류가 난다. 나머지가 안나와서
	data = 10. / 3.;
	// data는 int라서 정수 표현체계로 바꾼다. 소수점이 짤림
	data = (int)(10. / 3.);
	// 전체 연산의 결과를 int로 바꾸어 data에 집어 넣겠다는 뜻

	// float f = 10.2415f + (float)20;
	//data = 10. / 3.;
	// f를 붙일경우에는 float으로 보는 것이고 .만 붙인 것은 double로 보는 것

	return 0;
}
