
// 주석으로 처리되는 글자들은슬래쉬 두개를 쓴다
// 코드로 인식되지 않음


int main()
{
	// int : 자료형(date type) 어떤 자료의 형태인지 알려줌
	// i : 변수명 (자유롭게 정할수 있다)
	// 자료형 (괄호안은 크기 byte)
	// 정수형 : char(1), short(2), int(4), long(4), long long(8)
	// 실수형: float(4), double(8)
	// 1byte를 더 쪼개면 8bit로 나뉜다 이때 1비트가 메모리에서 최소단위 (0 or 1) 
	// 4byte = 32비트
	// 2의 10승 = 1kbyte, 1024kb = 1 MB, 1024MB = 1GB, 1024GB = 1TB ...
	// 1byte로 할수 있는 건? 1byte = 8bit
	// 8bit로 표현할 수 있는 가지수는 2**8 = 256가지 인데 
	// 이것으로 표현할 수있는 수의범위(정수만, 양수만) = 0 ~ 255까지
	// 정수형, 실수형을 나누는 이유는 메모리를 다루고 표현하는 방식이 완전히 다르기 때문이다.
	// 실수는 0 ~ 1까지 보더라도 무한대이다. 이것을 어떻게 비트로 표현할까? 부동소수점이라는 표현방식을 사용한다.
	
	
	// ++, -- (증감 연산자)
	// 한 단계 증가 또는 감소
	
	data = 0;
	data++;
	// data는 1이됨
	data++;
	// data는 2가됨

	data = 0;
	data--;
	data--;
	// 1씩 감소함

	// 무조건 1씩 감소하는 것이 아니라 한 단계씩 증가 및 감소함 !!!!! 경우에 따라 다를 수 있다.

	// 앞 혹은 뒤에 붙냐에 따라 연산자 우선순위가 바뀐다
	data = 0;
	++data; // 전위(전치)
	data++; // 후위(후치), 모든 연산자를 통틀어 가장 늦게 연산됨

	a = 10;
	data = a++;
	// a의 값을 넣고 증가한 것이기 때문에 data는 10이 됨
	data = ++a;
	// 이때는 11로 됨
	// ++은 변수 공간자체의 값이 변화하기 때문에 다시 대입할 필요가 없다.
	// 후위 연산자로 사용하는 경우, 연산자 우선순위가 가장 나중으로 밀린다.

	data = 0;
	data--;
	--data;
	// 굳이 전위 후위 따질 필요가 없지만 이럴 경우에도 전위로 쓰는 것이 좋다. 
	// 연산자는 특별한 사유가 없는한 전위로 사용한다.


	return 0;
}
