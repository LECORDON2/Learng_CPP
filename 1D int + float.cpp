
// 주석으로 처리되는 글자들은슬래쉬 두개를 쓴다
// 코드로 인식되지 않음


int main()
{
	// int : 자료형(date type) 어떤 자료의 형태인지 알려줌
	// i : 변수명 (자유롭게 정할수 있다)
	// 자료형 (괄호안은 크기 byte)
	// 정수형 : char(1), short(2), int(4), long(4), long long(8)
	// 실수형: float(4), double(8)
	// 1byte를 더 쪼개면 8bit로 나뉜다 이때 1비트가 메모리에서 최소단위 (0 or 1) 
	// 4byte = 32비트
	// 2의 10승 = 1kbyte, 1024kb = 1 MB, 1024MB = 1GB, 1024GB = 1TB ...
	// 1byte로 할수 있는 건? 1byte = 8bit
	// 8bit로 표현할 수 있는 가지수는 2**8 = 256가지 인데 
	// 이것으로 표현할 수있는 수의범위(정수만, 양수만) = 0 ~ 255까지
	// 정수형, 실수형을 나누는 이유는 메모리를 다루고 표현하는 방식이 완전히 다르기 때문이다.
	// 실수는 0 ~ 1까지 보더라도 무한대이다. 이것을 어떻게 비트로 표현할까? 부동소수점이라는 표현방식을 사용한다.
	

	// 정수형, 실수형을 나누는 이유는 메모리를 다루고 표현하는 방식이 완전히 다르기 때문이다.
	// 실수는 0 ~ 1까지 보더라도 무한대이다. 이것을 표현 하기위해 부동소수점이라는 표현방식을 사용한다.
	// 정수에서 4는 00000100이다
	int a = 4 + 4.0;
	// 4.0이라는 실수를 정수로 바꾸는 형변환이라는 과정이 존재한다.비효율적인 과정이며 실수가 발생할 수 있는 과정이다.
	
	// 실수에서는 특정숫자를 정확히 표현하는 것이 아니라 근삿값으로 표현함
	// 부동소수점 : 
	// 21.8125를 표현 ->  21 = 10101(이진법) 10101.1에서 0.1은 0.5라는 개념 2**-1, 2**-2, 2**-3으로 계속 내려감
	// 0.11010 = 0.5 + 0.25 + 0 + 0.0625 = 0.8125 
	// 즉 21.8125 = 10101.11010
	// 0.724254252 와 가장 근접한 숫자를 찾는것? float보다 double이 더 정밀하다

	// 정수표현 방식과 실수 표현 방식은 다르다
	// 실수 표현 방식은 정밀도에 의존한다.
	// 따라서 double(8) 자료형이 float(4) 보다 더 아래의 소수점까지 정확하게 표현이 가능하다.
	// 정수는 정수끼리, 실수는 실수끼리 연산하되, 두 표현방식의 피 연산자가 연산될 경우 명시적으로 편환하자
	// EX)
	float f = 10.2415f + (float)20;
	// 실수표현 체계에서의 20으로 바꿔줌, (float)를 적지 않아도 변환은 잃어남 그러나 명시적으로 적어주기


	return 0;
}
