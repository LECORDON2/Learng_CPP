#include <stdio.h>
#include <stdlib.h>


void output(const int* pI)
{
	int i = *pI;
	// 콘스트로 보기 때문에 접근하고 읽은 순 있다.


	*pI = 100;
	// 그러나 바꿀 순 없다.

	int* pInt = (int*)pI;
	*pInt = 1000;
	// 물론 이렇게 강제로 바꿀 순 있다.
	// const 포인터는 의도를 밝히는 거에 가깝다.


}


int main()
{
	// 1. const

	const int i = 100;

	// const와 포인터
	
	int a = 0;
	int* pInt = &a;

	// 포인터를 통해서 a라는 변수의 값을 바꿀수 있다.
	*pInt = 1;
	
	// 포인터 변수가 가리키는 주소를 바꿀수도 있다. 포인터의 값 자체?

	pInt = nullptr;
	// 이러면 아무것도 안가리키기 되는 것


	// 포인터 변수의 상수화의 두 개념
	// const와 포인터 변수가 만나면 포인터 변수가 가리키는 곳을 바꿀것인지 말것인지
	// 포인터 변수 자체가 상수가 되는 것


	
	
	// const 포인터
	const int* pConstptr = &a;
	*pConstptr = 100;
	// 이러면 컴파일러 오류가 난다. 포인터 변수가 가리키는 값이 상수화가 된 것

	int b = 0;
	pConstptr = &b;
	// 이렇게 쓰는 것은 문제가 없다. 포인터 변수의 주소값은 상수가 아니므로

	
	
	
	// 포인터 const
	int* const pIntConst = &a;
	// 포인터 변수 자체를 상수화 한 것

	*pIntConst = 400;
	// 이것은 가능하다

	pIntConst = &b;
	// 주소값은 받지 못한다.


	const int* const pConstIntconst = nullptr;
	// 둘다 상수화 하는 것


	// 초기화 시 가리킨 대상만 가리킴, 가리키는 원본을 수정 할 수 없음

	int const* p = &a;
	// 첫번째에 해당하는 것, const 가 수식하는 것이 포인터


	{
		int a = 0;
		const int* pInt = &a;
		*pInt = 100;
		// 이것은 되지 않는다.
		
		// 그러나 a = 100;는 가능하다.
		// 포인터의 기능을 제한한 것이라서 a랑은 관련이 없는 일이다.
		// 포인터의 기능에서 포인터가 가리키는 대상을 수정하는 기능이 상수화 된것
		// 이 포인터를 통해서는 수정할 수 없다.
		int* p = &a;
		*p = 100;
		// 그래서 이러한 포인터는 문제가 없다.



	}



	// 어떤 함수를 만들었는데 함수가 뭔가를 전달 받아야 된다. 그런 변수는 함수 스택안에 존재해야한다.
	// 그러나 입력받아야 하는 변수가 너무크다면 혹은 유일해야 한다면 
	// 함수가 종료되고 사라지면 매우 비효율 적이게 된다.
	// 그렇다면 포인터로 접근하면 되지 않나?
	// 그런데 포인터가 무서운 점은 포인터로 접근해서 변수가 달라질 수 있다.


	a = 100;
	output(&a);



	// 단축키 
	// 함수 선언 원형 : Ctrl + Shift + Space

	return 0;

}







